\chapter{Существующие решения}

\section{Математическая модель пользовательской активности ПО}
В статье \cite{mat_model} предлагается математическая модель активности пользователей ПО, основанная на теории последовательных шаблонов для предметной области оценки удобства использования. Данный способ совмещает анализ временных характеристик с вычислением уровней поддержки последовательных шаблонов.

Модель состоит из следующих элементов:
\begin{itemize}
	\item множество событий с атрибутами;
	\item множество классов событий;
	\item функция классификации событий;
	\item множество сессий до классификации;
	\item множество сессий после классификации и фильтрации;
	\item множество последовательных шаблонов;
	\item множество значений поддержки последовательных шаблонов;
	\item функция преобразования класса событий в затрачиваемое время.
\end{itemize}

%В качестве функции преобразовния класса событий в затрачиваемое время можно использовать метод оценки эффективности интерфейса – GOMS (Goals, Operators, Methods, Selection Rules – Цели, Операторы, Методы, Правила выбора соответственно), который включает в себя модель Keystroke-level Model (KLM) \cite{11}.

Данная модель может найти применение при оценке удобства использования пользовательских интерфейсов и для решения задач повышения эффективности взаимодействия пользователей с ПО.

Имея значения поддержки и затрачиваемого времени для каждого шаблона, эксперт может сконцентрироваться на наиболее значимых из них
для процесса работы пользователей с ПО в целом. Набор шаблонов при этом будет зависеть от целей проводимого анализа.

Далее эксперт может выдвинуть гипотезы о необходимых изменениях в пользовательском интерфейсе для повышения эффективности взаимодействия пользователей с ПО. При принятии решений эксперту необходимо учитывать множество различных факторов: особенности ПО, психологические факторы использования ПО и особенности пользователей.

Изменение пользовательского интерфейса повлечет изменение множеств событий, сессий и последовательных шаблонов, так как изменится
последовательность действий, необходимых для достижения пользователями поставленных целей.

Таким образом, можно утверждать, что задачей эксперта становится переход от текущей модели активности пользователей к новой, с иным составом сессий и шаблонов, следовательно, и иными значениями поддержки шаблонов и затратами времени пользователей.

После внесения изменений в программный интерфейс возможны повторный сбор и анализ данных активности пользователей, что может подтвердить либо опровергнуть выдвинутую ранее гипотезу.

Недостатком данной модели является использование заранее предопределенных шаблонов.

\section{Алгоритм получения ассоциативных правил Apriori}
Базовым алгоритмом, применяемым для получения ассоциативных правил, является алгоритм Apriori \cite{34}, автором которого является Ракеш Агравал (Rakesh Agrawal). Алгоритм Apriori использует стратегию поиска в ширину и осуществляет его снизу-вверх, последовательно перебирая кандидатов.
В алгоритме используются две структуры данных: $C_i$ — для хранения множества кандидатов в частые множества признаков длины $i$ и $F_i$ — для хранения частых множеств признаков длины $i$. Каждая структура имеет два поля — itemset, сохраняющее множество признаков, и support, которое хранит величину поддержки этого множества признаков. Ниже представлена формальная запись алгоритма состоящего из двух частей: самого Apriori и вспомогательной процедуры AprioriGen. 
%(рис. \ref{img:Apriori}).

%\imgsc{H}{0.7}{Apriori}{Алгоритм Apriori, перебор кандидатов шаблонов.}

%\newpage
Apriori$(Context, min\_supp)$. Context - набор данных, min\_supp - минимальная поддержка, $I_F$ -- все частые множества признаков.

\noindent
$C_1 \leftarrow \{1-itemsets\}  \\
i \leftarrow 1 \\
\textbf{while} (C_i \ne 0) \\
\textbf{do}
\begin{cases}
	SupportCount(C_i)\\
	F_i \leftarrow \{f \in C_i | f.support \ge min\_supp\} \text{//F -- частые сножества признаков} \\
	C_{i+1} \leftarrow AprioriGen(F_i) \text{//C -- кандидаты} \\
	i++
\end{cases} \\
\textbf{return}(I_F)$

%(рис. \ref{img:AprioriGen}).

%\imgsc{H}{0.7}{AprioriGen}{Алгоритм AprioriGen, формирование кандидатов шаблонов.}

AprioriGen$(F_i)$. $F_i$ - частые множества признаков длины $i$, $C_{i+1}$ -- потенциальные кандидаты частых множеств признаков.

\noindent
insert into $C_{i+1}$ // объеденение \\
select $p[1],p[2],...,p[i],q[i]$ \\
from $F_ip, F_iq$ \\
where $p[1]=q[1],...,p[i-1]=q[i-1],p[i]<q[i]$ \\
\textbf{for each} $c \in C_{i+1}$ // удаление \\
\textbf{do}
$\begin{cases}
	S \leftarrow (i-1)-\text{элементарные подмножства } c\\
	\textbf{for each } s \in S \text{// удаление} \\
	\textbf{do} 
	\begin{cases}
		\textbf{if } (s \notin F_i)\\
		\textbf{then } C_{i+1} \leftarrow C_{i+1} \backslash c
	\end{cases} \\
	\textbf{return} (C_{i+1})
\end{cases}$

Основной особенностью алгоритма можно считать использование свойства антимонотонности, которое гласит, что поддержка любого набора элементов не может превышать минимальной поддержки любого из его подмножеств. Именно благодаря этому свойству перебор не является «жадным» и позволяет обрабатывать большие массивы информации за секунды.

Существуют различные модификации алгоритма Apriori и иные алгоритмы \cite{35}, значительно оптимизированные под определенные ситуации. Можно утверждать, что применение существующего проработанного аппарата теории последовательных шаблонов позволит реализовать поиск новых (неизвестных ранее) шаблонов взаимодействия пользователей с информационной системой при меньших временных затратах.

\section{Алгоритм GSP}
Алгоритм GSP (англ. Generalized Sequential Pattern, обобщенный секвенциальный паттерн) является модификацией алгоритма AprioriAll, учитывающей ограничения по времени между соседними транзакциями \cite{1_, 32_}.

В случае с алгоритмом GSP требуется учитывать дополнительные условия, чтобы определить, содержит ли последовательность указанную подпоследовательность \cite{gsp}.

Введем такие параметры, как минимальное и максимальное допустимое время между транзакциями ($min\_gap$ и $max\_gap$), а также понятие скользящего окна, размера $win\_size$. Допускается, что элемент последовательности может состоять не из одной, а из нескольких транзакций, если разница во времени между ними меньше, чем размер окна.

Последовательность $d = \langle d_1...d_m \rangle$ содержит последовательность
$s = \langle s_1...s_m \rangle$ , если существуют такие целые числа $l_1 ≤ u_1 < l_2 ≤ u_2 < ... < l_n ≤ u_n$ , что:

\begin{enumerate}
\item $s_i$ содержится в объединении $d_k$, где $l_i ≤ k ≤ u_i, 1 ≤ i ≤ n$.
\item $t_{\text{транзакции}}(d_{l[i]}) - t_{\text{транзакции}} (d_{u[i-1]}) ≤ win\_size, 1 ≤ i ≤ n.$
\item $min\_gap ≤ t_{\text{транзакции}}(d_{l[i]}) - t_{\text{транзакции}}(d_{u[i-1]}) ≤ max\_gap,$ \newline $2≤i≤n.$
\end{enumerate}

Выполнение алгоритма GSP предусматривает несколько проходов по исходному набору данных. При первом проходе вычисляется поддержка для каждого предмета и из них выделяются частые. Каждый подобный предмет представляет собой одноэлементную последовательность. В начале каждого последующего прохода имеется некоторое число ЧВП (часто встречающихся последовательностей), выявленных на предыдущем шаге алгоритма. Из них будут формироваться более длинные последовательности-кандидаты.

Каждый кандидат представляет собой последовательность, длина которой \textit{на один больше} чем у последовательностей, из которых кандидат был сформирован. Таким образом, число элементов всех кандидатов одинаково. После формирования кандидатов происходит вычисление их поддержки. В конце шага определяется, какие кандидаты являются ЧВП. Найденные ЧВП послужат исходными данными для следующего шага алгоритма. Работа алгоритма завершается тогда, когда не найдено ни одной новой ЧВП в конце очередного шага, или когда невозможно сформировать новых кандидатов. Таким образом, в работе алгоритма можно выделить следующие основные этапы:

\begin{enumerate}
	\item[1.] Генерация кандидатов.
	\begin{enumerate}
		\item[1.1.] Объединение.
		\item[1.2.] Упрощение.
	\end{enumerate}
	\item[2.] Подсчет поддержки кандидатов.
\end{enumerate}

Недостатками подобных алгоритмов, существенно снижающими вычислительную эффективность обработки данных, являются:
\begin{itemize}
	\item большое количество обращений к базе данных, соответствующее длине максимального кандидата-последовательности;
	\item большое число генерируемых кандидатов-последователь-ностей.
\end{itemize}

\section{Метод оценки эффективности интерфейса GOMS}
Метод GOMS (сокращение от Goals, Operators, Methods and Selection Rules -- Цели, Операторы, Методы и Правила выбора) -- это семейство методов, позволяющих провести моделирование выполнения той или иной задачи пользователем и на основе такой модели оценить качество интерфейса.

Идея метода заключается в разбиении взаимодействия пользователя с интерфейсом на атомарные физические и когнитивные действия. Обладая знаниями о метриках каждой из таких составляющих, можно делать заключение об эффективности взаимодействия в целом: оценка
эффективности интерфейса сводится к разбиению типовых задач на элементарные действия и сложению метрик каждого из них.

Метод GOMS включает в себя модель Keystroke-level Model (KLM) \cite{11}, которая выделяет следующие элементарные задачи и длительность каждой из них (рассчитанные на основе усредненных данных лабораторных испытаний):

\begin{itemize}
	\item K – нажатие на клавишу в зависимости от уровня владения клавиатурой: профессиональный	наборщик – 0.08 сек., эксперт – 0.12 сек., частая работа с текстом – 0.20 сек., продвинутый пользователь – 0.28 сек., неуверенный пользователь – 0.5 сек., не знакомый с клавиатурой – 1.2 сек.;
	\item P – указание курсором мыши на объект – 1.1 сек.;
	\item B – нажатие или отпускание мыши – 0.1 сек.;
	\item M – умственная подготовка, выбор действия – 1.2 сек.;
	\item H – перемещение руки в исходное положение на клавиатуре – 0.4 сек;
	\item R – ожидание ответа системы, зависящее от	времени выполнения системой запрошенной операции.
\end{itemize}

Оценка времени на решение задачи сводится к сложению продолжительностей каждой из простейших составляющих. Например, задача, состоящая из классов (P, P, B), потребует для завершения 2.3 сек. (1.1 сек. + 1.1 сек. + 0.1 сек.).


\section{Классификация}
Рассмотрев вышеописанные методы анализа пользовательской активности, можно их разделить на следующие категории:
\begin{itemize}
%	\item поиск последовательных шаблонов; %поиск ассоциативных правил;
	\item поиск ассоциативных правил;
	\item поиск последовательных шаблонов;
	\item сбор и анализ временных характеристик выполнения пользователем действий и промежутков между ними;
	\item вычисление уровней поддержки шаблонов поведения пользователя.
\end{itemize}

Вычисление уровней поддержки шаблонов поведения пользователя позволяет ранжировать их по степени приоритета для детального анализа.
Методы поиска ассоциативных правил и последовательных шаблонов позволяют найти новые (неизвестные ранее) шаблоны взаимодействия пользователей с программным обеспечением.
А анализ временных характеристик, позволяет оценить эффективность взаимодействия пользователя с интерфейсом.