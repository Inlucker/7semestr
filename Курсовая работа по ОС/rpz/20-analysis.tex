\chapter{Аналитический раздел}
\label{cha:analysis}
%
% % В начале раздела  можно напомнить его цель
%
\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра, перехватывающий события в системе и передавать информацию о них на удаленный компьютер. В рамках данной работы для выполнения перехвата был выбран системный вызов $sys\_clone$.

% Добавить формализацию задачи (цель и задачи)
Для решения поставленной цели необходимо решить следующие задачи:
\begin{enumerate}
	\item проанализировать существующие методы перехвата системных функций;
	\item реализовать загружаемый модуль ядра;
	\item реализовать сервер, передающий информацию на удаленный компьютер;
	\item исследовать результаты работы разработанного модуля.
\end{enumerate}

% Обратите внимание, что включается не ../dia/..., а inc/dia/...
% В Makefile есть соответствующее правило для inc/dia/*.pdf, которое
% берет исходные файлы из ../dia в этом случае.

\section{Методы перехвата функций ядра Linux}

%\begin{itemize}
%	\item Linux Security API
%	\item Модификация таблицы системных вызовов
%	\item Использование kprobes
%	\item Сплайсинг
%	\item Новый подход с ftrace
%	\end{itemize}

\subsection{Linux Security API}
Linux Security API — специальный интерфейс, созданный именно для перехвата системных функций. В критических местах кода ядра расположены вызовы security-функций, которые в свою очередь вызывают коллбеки, установленные security-модулем. Security-модуль может изучать контекст операции и принимать решение о её разрешении или запрете.

У Linux Security API есть пара важных ограничений:
\begin{itemize}
	\item security-модули не могут быть загружены динамически, являются частью ядра и требуют его пересборки;
	\item в системе может быть только один security-модуль (с небольшими исключениями).
\end{itemize}

Если по поводу множественности модулей позиция разработчиков ядра неоднозначная, то запрет на динамическую загрузку принципиальный: security-модуль должен быть частью ядра, чтобы обеспечивать безопасность постоянно, с момента загрузки. Таким образом, для использования Security API необходимо поставлять собственную сборку ядра, а также интегрировать дополнительный модуль с SELinux или AppArmor, которые используются популярными дистрибутивами.

\subsection{Модификация таблицы системных вызовов}
Linux хранит все обработчики системных вызовов в таблице sys\_call\_table. Подмена значений в этой таблице приводит к смене поведения всей системы. Таким образом, сохранив старое значения обработчика и подставив в таблицу собственный обработчик, можно перехватить любой системный вызов.

У этого подхода есть следующие преимущества:
\begin{itemize}
	\item полный контроль над любыми системными вызовами;
	\item отсутствие необходимости в каких-либо дополнительных конфигурационных опций в ядре.
\end{itemize}

Однако, подход не лишен недостатков:
\begin{itemize}
	\item техническая сложность реализации - необходимо выполнить сопутствующие задачи: поиск таблицы системных вызовов; обход защиты от модификации таблицы; атомарное и безопасное выполнение замены;
%	\begin{itemize}
%		\item поиск таблицы системных вызовов
%		\item обход защиты от модификации таблицы
%		\item атомарное и безопасное выполнение замены
%	\end{itemize}
	\item невозможность перехвата некоторых обработчиков;
	\item перехватываются только системные вызовы.
\end{itemize}

Данный подход позволяет полностью подменить таблицу системных вызовов что является несомненным плюсом, но также ограничивает количество функций, которые можно мониторить.

\subsection{Использование kprobes}
Kprobes - специализированное API, в первую очередь предназначенное для отладки ядра. Этот интерфейс позволяет устанавливать пред- и постобработчики для любой инструкции в ядре, а также обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут их изменять. Таким образом, можно было бы получить как мониторинг, так и возможность влиять на дальнейший ход работы.

Преимущества, которые даёт использование kprobes для перехвата:
\begin{itemize}
	\item хорошая документация API;
	\item перехват любого места в ядре - Kprobes реализуются с помощью точек останова (инструкции int3), внедряемых в исполнимый код ядра.
\end{itemize}

Недостатки kprobes:

\begin{itemize}
	\item для получения аргументов функции или значений локальных переменных надо знать, в каких регистрах или где на стеке они лежат, и самостоятельно их оттуда извлекать;
	\item для блокировки вызова функции необходимо вручную модифицировать состояние процесса;
	\item накладные расходы из-за расстановки точек останова и их обработки;
	\item возможность переполнения буфера, хранящего адреса возврата, когда в системе выполняется слишком много одновременных вызовов перехваченной функции, в следствии чего будут пропускаться срабатывания отслеживаемых функций;
	\item в обработчиках нельзя ждать, выделять много памяти, спать в таймерах и семафорах и т.п. из-за отключенного вытеснения.
\end{itemize}

\subsection{Сплайсинг}
Сплайсинг – способ перехвата функций, основанный на замене инструкций в начале функции на безусловный переход, ведущий в обработчик. Исходные инструкции исполняются перед переходом обратно в
перехваченную функцию. С помощью двух таких переходов выполняется
дополнительный код. С помощью сплайсинга реализуются некоторые
оптимизации kprobes.

Преимущества сплайсинга:
\begin{itemize}
	\item сплайсинг не требует каких-либо особенных опций в ядре
	\item для перехвата нужно знать только адрес функции.
	\item воздействие не отлавливается антивирусами и детекторами
	вредоносных программ;
	\item обеспечение подключения любого символа ядра.
\end{itemize}

Недостатки:
\begin{itemize}
	\item техническая сложность реализации, необходимо решить следующие задачи: синхронизация установки и снятия перехвата; обход защиты от модификации областей памяти с исходным кодом ядра; инвалидация кешей процессора после замены инструкци; дизассемблирование заменяемых инструкций, чтобы скопировать их целыми; проверка на отсутствие переходов внутрь заменяемого куска; проверка на возможность переместить заменяемый кусок в другое место.
%	\begin{itemize}
%		\item синхронизация установки и снятия перехвата
%		\item обход защиты на модификацию регионов памяти с кодом
%		\item инвалидация кешей процессора после замены инструкций
%		\item дизассемблирование заменяемых инструкций, чтобы скопировать их целыми
%		\item проверка на отсутствие переходов внутрь заменяемого куска
%		\item проверка на возможность переместить заменяемый кусок в другое место
%	\end{itemize}
\end{itemize}

\subsection{Новый подход с ftrace}
Ftrace — это фреймворк для трассирования ядра на уровне функций. Он разрабатывается с 2008 года и обладает удобным интерфейсом для пользовательских программ. Ftrace позволяет отслеживать частоту и длительность вызовов функций, отображать графы вызовов, фильтровать интересующие функции по шаблонам, и так далее.

Реализуется ftrace на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_(). Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками, чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

Для некоторых архитектур доступна оптимизация: динамический ftrace, который на ранних этапаха загрузки заменяет вызовы mcount() и \_\_fentry\_\_() на инструкцию nop — специальную ничего не делающую инструкцию. При включении трассирования в нужные функции вызовы ftrace добавляются обратно. Таким образом, если ftrace не используется, то его влияние на систему минимально.

Преимущества:
\begin{itemize}
	\item хорошо задокументированный интерфейс;
	\item перехват любой функции по имени;
	\item минимальное влияние на систему при выключенном трассировании;
	\item перехват совместим с трассировкой.
\end{itemize}

Недостатки:
\begin{itemize}
	\item требования к конфигурации ядра - для успешного выполнения перехвата функций с помощью ftrace ядро должно предоставлять ряд возможностей: список символов kallsyms для поиска функций по имени; фреймворк ftrace в целом для выполнения трассировки; опции ftrace, критически важные для перехвата.
%	\begin{itemize}
%		\item список символов kallsyms для поиска функций по имени;
%		\item фреймворк ftrace в целом для выполнения трассировки;
%		\item опции ftrace, критически важные для перехвата.
%	\end{itemize}
%	\item Накладные расходы на ftrace меньше, чем у kprobes (так как ftrace не использует точки останова), но они выше, чем у сплайсинга. Действительно, динамический ftrace, является сплайсингом, только вдобавок выполняющий код ftrace и другие коллбеки.
	\item ftrace срабатывает исключительно при входе.
\end{itemize}

\newpage
\section{Сравнительный анализ методов перехвата системных вызовов}
В таблице \ref{t1} приведен сравнительный анализ рассмотренных методов.

\begin{table}[H]
	\caption{Cравнительный анализ методов перехвата функций ядра Linux}
	\label{t1}
	\centering
	\resizebox{\columnwidth}{!}{
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			& Документация API & \specialcell{Техническая простота \\ реализации} & \specialcell{Перехват любых \\ функций} & \specialcell{Перехват функции \\ по имени} \\ \hline
			Linux Security API & - & + & + & - \\  \hline
			\specialcell{Модификация таблицы \\ системных вызовов} & - & + & - & - \\  \hline
			kprobes & + & - & + & - \\  \hline
			Сплайсинг & - & - & + & - \\  \hline
			ftrace & + & + & + & + \\  \hline
	\end{tabular}}
\end{table}

\section{Выводы}
В результате проведенного анализа подходов к реализации мониторинга за вызовами функций ядра, был выбран подход с ftrace. Первоначально был выбран способ с подменой таблицы системных вызовов. Однако, при реализации возникли следующие проблемы:
\begin{itemize}
	\item после релиза ядра версии 3.0, таблицу больше нельзя получить простым импортом нужного модуля;
	\item не работает на ядрах выше версии 4.16, так как участок памяти, в котором она находится, заблокирован, а его разблокировка ведет к ошибке установки модуля;
	\item не позволяет следить за чем-то кроме функций, находящихся в таблице системных вызовов.
\end{itemize}

Для реализации поставленной задачи, использовалось ядро 5.4.0, и выбран способ с использованием фреймворка ftrace. Подход поддерживает ядра версий 3.19+ для архитектуры x86\_64.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
